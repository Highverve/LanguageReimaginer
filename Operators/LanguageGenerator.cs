using LanguageReimaginer.Data;
using LanguageReimaginer.Data.Elements;
using System.Text;
using System.Text.RegularExpressions;

namespace LanguageReimaginer.Operators
{
    /// <summary>
    /// Generator breakdown:
    /// 
    /// 1. Flagging. All valid flags are read, and changes are applied.
    /// 2. Lexemes. All valid affixes are grabbed and separated. The root word is retrieved.
    /// 3. Preparation. The generated word's foundation is prepared.
    ///     - The syllable count of the root word is estimated, by checking the boundaries of "VC" and "CV".
    ///       Example: in·ter·est·ing·ly -> VC·CVC·VC(C)·V(C)C·CV. Double consonants/vowels are stripped (ignored).
    ///     - The syllable structure is generated, according to the language author's specifications. "CCV·VC·VC·CV"
    ///     - The first letter is chosen, according to the first sigma's C/V, and the language's letter weight distribution.
    ///     - The letter pathways are generated by the language author's constraints.
    /// 4. The sigmas are merged together, with any punctuation in between preserved. Affixes are prepended and appended in order.
    /// 5. The word is complete! Repeat for the next word until the sentence is processed and returned.
    /// 
    ///     Lexemes in action: "interestingly"
    ///         |est| is handled entirely by the generator.
    ///         |inter|, |ing|, and |ly| are all affixes. They are handles by the lexeme rules.
    ///     
    ///     Flags in action: "Bateman's**xp" and "dog's**p"
    ///         |Bateman's| is skipped entirely. **x skips generation. **p skips contraction rules, however, **x also superceeds it.
    ///         |'s| is processed according to the language's possessive rules. |dog| is processed as normal.
    ///         
    ///     
    /// 
    /// </summary>
    public class LanguageGenerator
    {
        internal RandomGenerator RanGen { get; set; } = new RandomGenerator();
        //internal SyllableGenerator SyllableGen { get; set; }

        List<WordInfo> wordInfo = new List<WordInfo>();
        StringBuilder sentenceBuilder = new StringBuilder();

        private Language language;
        public Language Language
        {
            get { return language; }
            set
            {
                language = value;
                RanGen.Language = language;
            }
        }

        public LanguageGenerator() { }
        public LanguageGenerator(Language Language) { this.Language = Language; }

        public string Generate(string sentence, out List<WordInfo> info)
        {
            sentenceBuilder.Clear();
            wordInfo.Clear();
            sigmaInfo.Clear();

            //Pre: Split words by delimiter and add to WordInfo list.

            //Deconstructing a word.
            //1. Punctuation marks (1 of 2). Loop through WordInfo list, isolate all punctuation marks (e.g., comma, or quote/comma),
            //   add punctuation to WordInfo.
            //2. Flagging. Check for flag marcation, add flags to WordInfo, process flags.
            //3. Lexemes. Check for affixes, add prefixes and suffixes to WordInfo.

            //Constructing a new word.
            //4. Estimate sigma (syllable) count by checking the boundaries of "VC" and "CV".
            //5. Generate sigma structure; by length of actual sigma count * sigma weight. "CCV·VC·VC·CV"
            //6. The first letter of the word is chosen; by first sigma's C/V, then by start letter weight.
            //7. The next letters are chosen, according to the pathways set by the language author.

            //Combining together.
            //8. The sigmas of the root word are combined in order.
            //9. The new affixes are retrieved and placed in order.
            //10. The new punctuation marks are adding to the end of the word.


            //This should split a word by the delimiters, and then leave the delimiter at the end.
            string[] words = Regex.Split(sentence, "@\"(?<=[" + string.Join("", Language.Options.Delimiters) + "])\"");

            //Loop through split words and add to wordInfo list.
            foreach (string s in words)
            {
                WordInfo word = new WordInfo();
                word.WordActual = s;

                wordInfo.Add(word);
            }

            //Link adjacent words.
            for (int i = 0; i < wordInfo.Count; i++)
            {
                if (i != 0)
                    wordInfo[i].AdjacentLeft = wordInfo[i - 1];
                if (i != wordInfo.Count - 1)
                    wordInfo[i].AdjacentRight = wordInfo[i + 1];
            }

            foreach (WordInfo part in wordInfo)
            {
                bool skipGeneration = false;
                bool skipLexemes = false;

                //FLAGGING!
                if (Language.Flagging.ContainsFlag(part.WordActual))
                {
                    //Add any flags as char array to WordInfo.
                    int marcation = Language.Flagging.FlagIndex(part.WordActual);
                    string flags = part.WordActual.Substring(marcation, part.WordActual.Length - marcation); //May need + Flagging.Marcation.Length to startIndex.
                    string flagsFinal = string.Empty;

                    foreach (char c in flags)
                    {
                        if (Language.Flagging.Flags.ContainsKey(c))
                            flagsFinal += c;
                    }

                    part.Flags = flagsFinal.ToCharArray();
                }

                //Set generator-level flags.
                if (part.Flags?.Any() == true && part.Flags.Contains('X') == true) skipGeneration = true;
                if (part.Flags?.Any() == true && part.Flags.Contains('x') == true) skipLexemes = true;

                //LEXEMES!
                if (skipLexemes == false) ProcessLexemes(part);
                else part.WordRoot = part.WordActual;

                //Set random of root word.
                RanGen.SetRandom(part.WordRoot);

                //TO-DO:
                //1. Check for punctuation marks. If the sentence contains any, then: isolate (Add before or after
                //2. Check for and process lexemes.

                //sentenceBuilder.Append(NextWord(s) + " ");

                ConstructWord(part);
            }

            info = wordInfo;
            return sentenceBuilder.ToString();
        }
        private void ProcessLexemes(WordInfo part)
        {
            //Extract affixes.
            part.Prefixes = Language.Lexemes.GetPrefixes(part.WordActual).ToArray();
            part.Suffixes = Language.Lexemes.GetSuffixes(part.WordActual).ToArray();

            //Strip word to root.
            int prefixLength = part.Prefixes.Sum((a) => a.Key.Length);
            int suffixLength = part.Suffixes.Sum((a) => a.Key.Length);
            part.WordRoot = part.WordActual.Substring(prefixLength, part.WordActual.Length - suffixLength);
        }

        List<SigmaInfo> sigmaInfo = new List<SigmaInfo>();
        private void ConstructWord(WordInfo part)
        {
            //Constructing a new word.
            //4. Estimate sigma (syllable) count by checking the boundaries of "VC" and "CV".
            //5. Generate sigma structure; by length of actual sigma count * sigma weight. "CCV·VC·VC·CV"
            //6. The first letter of the word is chosen; by first sigma's C/V, then by start letter weight.
            //7. The next letters are chosen, according to the pathways set by the language author.

            int sigmaCount = SigmaCount(part.WordRoot); // * random.NextDouble(minSkew, maxSkew)

            //Generate sigma structure.
            for (int i = 0; i < sigmaCount; i++)
            {
                //5.1 Select sigma by sigma's weights and the language's sigma options.
                SigmaInfo info = new SigmaInfo();
                Sigma last = (sigmaInfo.LastOrDefault() != null) ? sigmaInfo.LastOrDefault().Sigma : null;
                Sigma sigma = SelectSigma(i, last);
                info.Sigma = sigma;
                
                sigmaInfo.Add(info);
            }

            //Link adjacent sigma.
            for (int i = 0; i < sigmaInfo.Count; i++)
            {
                if (i != 0)
                    sigmaInfo[i].AdjacentLeft = sigmaInfo[i - 1];
                if (i != sigmaInfo.Count - 1)
                    sigmaInfo[i].AdjacentRight = sigmaInfo[i + 1];
            }

            //Build letters in sigma.
            foreach (SigmaInfo s in sigmaInfo)
                SelectLetter(s);

            //Compile affixes
            foreach (Affix p in part.Prefixes)
                part.WordPrefixes += p.Value;
            foreach (Affix s in part.Suffixes)
                part.WordSuffixes += s.Value;

            //Assemble word from sigmas
            foreach (SigmaInfo s in sigmaInfo)
                part.WordGenerated += (s.Onset + s.Nucleus + s.Coda);
            part.Syllables = sigmaInfo;

            //Put it all together.
            part.WordFinal = part.WordPrefixes + part.WordGenerated + part.WordSuffixes;
            sentenceBuilder.AppendLine(part.WordFinal);
        }
        private Sigma SelectSigma(int sigmaPosition, Sigma lastSigma)
        {
            //Temporary
            return Language.Structure.SigmaTemplates[RanGen.Random.Next(0, Language.Structure.SigmaTemplates.Count)];
        }
        private void SelectLetter(SigmaInfo sigma)
        {
            List<Consonant> consonants = Language.Alphabet.Consonants.Values.ToList();
            List<Vowel> vowels = Language.Alphabet.Vowels.Values.ToList();

            if (sigma.Sigma.Onset.Count > 0)
            {
                for (int i = 0; i < sigma.Sigma.Onset.Count; i++)
                    sigma.Onset += consonants[RanGen.Random.Next(0, consonants.Count)].Value;
            }

            if (sigma.Sigma.Nucleus.Count > 0)
            {
                for (int i = 0; i < sigma.Sigma.Nucleus.Count; i++)
                    sigma.Nucleus += vowels[RanGen.Random.Next(0, vowels.Count)].Value;
            }

            if (sigma.Sigma.Coda.Count > 0)
            {
                for (int i = 0; i < sigma.Sigma.Coda.Count; i++)
                    sigma.Coda += consonants[RanGen.Random.Next(0, consonants.Count)].Value;
            }
        }
        private void SelectConsonant() { }
        private void SelectVowel() { }

        /// <summary>
        /// Roughly estimates a word's syllables. It transforms the word into c/v, and counts where a consonant shares a border with a vowel. Only misses where a consonant could also be a vowel (such as "y")).
        /// </summary>
        /// <param name="word"></param>
        /// <returns></returns>
        public int SigmaCount(string word)
        {
            string cv = string.Empty;

            foreach (char c in word)
            {
                if (Language.Options.InputConsonants.Contains(c)) cv += 'c';
                if (Language.Options.InputVowels.Contains(c)) cv += 'v';
            }

            int result = 0;
            while (cv.Length > 1)
            {

                //Check for consonant-vowel border.
                if ((cv[0] == 'c' && cv[1] == 'v') ||
                    (cv[0] == 'v' && cv[1] == 'c'))
                {
                    result++;
                    cv = cv.Remove(0, Math.Min(cv.Length, 2));
                }

                if (cv.Length <= 1)
                    break;

                //If double consonant or vowel, remove one.
                if ((cv[0] == 'c' && cv[1] == 'c') ||
                    (cv[0] == 'v' && cv[1] == 'v'))
                {
                    cv = cv.Remove(0, 1);
                }
            }

            return result;
        }
    }
}
